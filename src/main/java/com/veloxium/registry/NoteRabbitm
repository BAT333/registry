primeiro de tudo nos tem instalar eler ou instalar img dele
deste jeito pelo docker
# latest RabbitMQ 3.10
docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.10-management
localhost:15672 -> site para acessar
qualquer coisa outras coisas estão aqui
https://hub.docker.com/_/rabbitmq/

senha e user padrão
Username: guest
Password: guest

Primeiramente, vou criar uma pasta chamada rabbit e um novo arquivo chamado docker-compose.yml.
Nele podemos colocar as informações básicas abaixo, que correspondem aos mesmos parâmetros que
usamos ao criar o container com o comando docker run. Aqui ainda acrescentei variáveis de ambiente
para definir um usuário e uma senha padrão, para que não seja mais possível logar com guest.


version: "3.6"

services:
    rabbitmq:
        image: rabbitmq:3.10-management
        container_name: rabbitmq
        restart: always
        ports:
            - 5672:5672
            - 15672:15672
        volumes:
            - ./dados:/var/lib/rabbitmq/
        environment:
            - RABBITMQ_DEFAULT_USER=jacqueline
            - RABBITMQ_DEFAULT_PASS=aluraCOPIAR CÓDIGO
Com o arquivo pronto, basta digitar o comando docker-compose up para criar
e executar o RabbitMQ automaticamente. Para finalizar, o procedimento é
igualmente simples, bastando digitar o comando docker-compose down.

docker-compose up

docker-compose down


docker-compose -f mysql-docker-compose.yml up -d
ou esse aqui quando precisa especificar

----------------------------------------CONFIGURANDO PROJETO----------------------------------------------------------
PRIMEIRO TEMOS QUE ADD A DEPENDENCIA
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

NO APPLICANTION
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=rafael
spring.rabbitmq.password=rafael234

configuração do rabbitmq
depois criar uma class de configuração

package com.veloxium.registry.infra.ampq;

import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;

public class RegisterAMPQConfiguration {
    @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }
}

 @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }
    AQUI SERVE PARA CRIAR UMA FILA NO SEU RABBITM CRIA UMA FILA COM NOME QUE VC COLOCOU
    E SE ESSA FILA DURAVEL OU NÃO, ESSA SÃO DUAS FORMAS DE CRIAR ESSA FILA

    AGORA PARA FAZER  OPERAÇÃO ADIMINISTRATIVA
    NÃO PRECISA CRIAR UM RABBITM ADM, OQ É ?
    Mas para realizarmos operações administrativas no RabbitMQ, precisamos declarar um método que retorna um RabbitAdmin. Vamos analisar a documentação!
 Nesta documentação, em "Constructor Summary", ele nos informa que para montar o construtor, precisamos de uma ConnectionFactory ou de um RabbitTemplate. No caso, não usaremos este último, porque ele é mais voltado para o envio das mensagens, vamos utilizá-lo no controlador. Portanto, vamos usar a ConnectionFactory.
    Class RabbitAdmine
    PARA CRIAR UMA CON para fazer uma con,
    @Bean
        public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory){
            return new RabbitAdmin(connectionFactory);
        }
   agora precisamos de um jeito inicializar quando nos inicia nossas aplicação
   como se faz isso
       @Bean
       public ApplicationListener<ApplicationReadyEvent> startingRabbitAdimin(RabbitAdmin rabbitAdmin){
           return event -> rabbitAdmin.initialize();
       }


       Além de criar o nome da fila e o Rabbit Admin, precisamos de uma forma de inicializar o RabbitMQ ao subirmos a aplicação, isto é, sincronizar para conseguir realizar as operações. Para isso, vamos usar uma interface chamada ApplicationListener.

       public ApplicationListener<>COPIAR CÓDIGO
       Ao digitarmos "ApplicationListener", por padrão, já aparece um menu com algumas opções, em que escolheremos a "ApplicationReadyEvent org.springframework.boot.context.event". O nome será inicializaAdmin e passaremos como parâmetro o RabbitAdmin.
-----------------------------------------------NO FINAL CLASS FICA ASSIM------------------------------------------------------------------------
package com.veloxium.registry.infra.ampq;

import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitAdmin;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;

public class RegisterAMPQConfiguration {
    @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }
    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory){
        return new RabbitAdmin(connectionFactory);
    }
    @Bean
    public ApplicationListener<ApplicationReadyEvent> startingRabbitAdimin(RabbitAdmin rabbitAdmin){
        return event -> rabbitAdmin.initialize();
    }
}
-------------------------------------------------Publicando mensagens-----------------------------------------------------------------------------------------------------
@Autowired
private RabbitTemplate template;
var message =  new Message(("CRIEI USER COM ID"+ employee.id()).getBytes());
template.send("registered.completed",message);
vc instancia RabbitTemplate que envia mensagem
e depois usar .sende, e tem ass a fila que vc criou que no nosso caso registered.completed
e mensagem que vau ser enviada com ela vc cria variavel de mensagem

sempre usando essas dependencias
import org.springframework.amqp.core.Message;
--------------------------------------RECEBER MENSAGEM-------------------------------------------------------------------------------------------
PRIMEIRO VC CONFIGURA TODO LOCAL , COLOCANDO AS DEPENDENCIAS, COLOCANDO O COMO CONECATAR TUDO MAIS
PRECISA FAZER UMA CLASSE PARA LER OU RECEBER UMA CLASS
agora precisamos criar uma nova classe para declarar como vamos receber e ler mensagens de uma fila. Para isso, usaremos o Rabbit Listener.

O Rabbit Listener é uma interface que permite o recebimento de mensagens de uma fila ou dado
um bind com alguma exchange. Na documentação, em "Optional Element Summary"
(em português, "Resumo do elemento opcional"), há várias opções que você pode analisar,
mas vamos trabalhar com a queues.

PARA ISSO VAMOS CRIAR UMA CLASS

por padrão nos coloca nome do que vamos receber
RegisterListener

e assim recebe uma mensagem
  @RabbitListener(queues = "registered.completed")
    public void  receivingMessage(Message message){
        System.out.println("RECEBI TAL MENSAGEM "+ message.toString());
    }
----------------------------------------------Transferindo representações---------------------------------------------------------------
COMO TRASFERIR UM OBJETO INTEIRO
rabbitTemplate.convertAndSend("pagamentos.concluido", pagamento);
convertAndSend
SERVE PARA TRASFERIR UM OBJETO OU UM DTO INTEIRO
MAS MESMO ASSIM DA ERRO POR QUE PRECISA QUE SEJA EM BYTE
COMO RESOLVER

Para isso nos temos que trocar conversor padrão para outro que suporta esse tipo de transferência
e qual vamos usar
Ao invés de usarmos o SimpleMessageConverter, em que não informamos nada, somente passamos o pagamento e mandamos ele tentar enviar, usaremos o
Jackson2JsonMessageConverter.
para isso precisamos avisar na configuração que vamos usar um metodo diferente de conversão

na classe de configuração

 so add a dependencia com bean de conversão
   @Bean
     public Jackson2JsonMessageConverter messageConverter(){
         return new Jackson2JsonMessageConverter();
     }
Tbm nos temos que falar que vai ter essa mudança no rabbitTemplate que vai ter essa mudança e
conversão
como faremos isso ?
oq faz isso é o setMessageConverter que faz essa mudança

assim fica nesse final
    @Bean
    public RabbitTemplate template(ConnectionFactory connectionFactory,Jackson2JsonMessageConverter messageConverter){
        var rabbit = new RabbitTemplate(connectionFactory);
        rabbit.setMessageConverter(messageConverter);
        return rabbit;
    }
mostrando que template tem essa mudanças
no final fica assim essa class
package com.example.userSeguranca.config.ampq;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitAdmin;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RegisterAMPQConfiguration {
    @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }
    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory){
        return new RabbitAdmin(connectionFactory);
    }
    @Bean
    public ApplicationListener<ApplicationReadyEvent> startingRabbitAdimin(RabbitAdmin rabbitAdmin){
        return event -> rabbitAdmin.initialize();
    }
    @Bean
    public Jackson2JsonMessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
    @Bean
    public RabbitTemplate template(ConnectionFactory connectionFactory,Jackson2JsonMessageConverter messageConverter){
        var rabbit = new RabbitTemplate(connectionFactory);
        rabbit.setMessageConverter(messageConverter);
        return rabbit;
    }
}
--------------------------------------------------Manipulando os dados recebidos------------------------------------------------------------
PARA RECEBER OS DADOS PRIMEIRO PRECISAMOS QUE TENHA UMA CLASS IGUAL RECEBENDO
COM ID NOME ETC

POR EXEMPLO CLASS QUE ESTA MANDANDO MINHA É ESSA
package com.example.userSeguranca.infra.controller.modal;

import jakarta.validation.constraints.NotNull;
import jdk.jfr.Name;
CLASS ENVIANDO
public record DataLoginsDTO(
        Long id,
        @NotNull
        String login,
        @NotNull
        String password

) {
}
PRECISA TER UMA CLASS PARECIDA PARA RECEBER
class que esta recebendo minha praticamente a mesma com mesmo nome tudo mais
CLASS RECEBENDO
public record DataLoginsDTO(
        Long id,
        @NotNull
        String login,
        @NotNull
        String password

) {
}
SE TIVER ENUM OUTRAS CLASS COM RECEBIMENTOS A MAIS TEM CRIAR CLASS PARECIDAS TBM


para receber class tem criar class de configuração com padrão de recebimento
por exemplo nos usamos Jackson2JsonMessageConverter e temos que informa que esse tipo de recebimento
tbm

assim fica class de configuração
package com.veloxium.registry.infra.ampq;

import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RegistryAMPQconfig {
    @Bean
    public Jackson2JsonMessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
    @Bean
    public RabbitTemplate template(ConnectionFactory connectionFactory, Jackson2JsonMessageConverter messageConverter){
        var rabbit = new RabbitTemplate(connectionFactory);
        rabbit.setMessageConverter(messageConverter);
        return rabbit;
    }
}

AGORA NOS TEMOS QUE CONFIGURA LISTENER PARA MOSTRA COMO ELE VAI RECEBER
-------------------------------------Trabalhando com exchanges-----------------------------------------------------------------------------
PARA QUE UMA FILA MANDE MENSAGEM PARA UM OU MAIS MS

Fanout exchange com implementar
vamos começando a excluir uma fila
  @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }

POR QUE VAMOS PRECISAR SO DE UMA EXCHANGE NÃO UMA FILA INTEIRA POR MOTIVOS QUE EXCHANGE
COM EXCHANGE AS FILAS E APLICAÇÃO VÃO PROPRIAS SE CRIAR E IMPLEMENTAR


AGORA INVES DESTA FILA VAMOS CRIAR UMA FANOUTEXCHANGE COMO SE CRIA
  @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange("login.ex");
    }
e colocar nome que vai criar tudo mais  esse FANOUTEXCHANGE
depois nos temos que modificar  controller
por que nos não vamos mais mandar para uma fila (registered.completed) mas sim para
para um fanoutExchange(login.ex)
e ficara assim
template.convertAndSend("login.ex","",user);
bom vc vai mandar so para ex, mas se vc quiser que esse ex mande para uma especifica colocava tbm
fila que vc quer mandar
--------------------------------quem vai receber---------------------------------------------------
primeiro vamos trasferir reposnsabilidade que vai criar a fila agora é quem vai receber

assim vai ficar fila criada
 @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder.nonDurable("registered.completed").build();
    }

essa fila criada onde tem Listener

e para dizer qual Exchange ta recebendo nos temos que criar bean dizendo isso
    @Bean
    public FanoutExchange fanoutExchange(){
        return ExchangeBuilder
                .fanoutExchange("login.ex").build();
    }
agora nos precisamos ligar os dois
assim vc liga
    @Bean
    public Binding binding(FanoutExchange exchange){
        return BindingBuilder.bind(creatingQueue()).to(fanoutExchange());
    }
    vc diz qual é fila e qual fanout

    e tbm precisa do
      @Bean
        public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory){
            return new RabbitAdmin(connectionFactory);
        }
        @Bean
        public ApplicationListener<ApplicationReadyEvent> startingRabbitAdimin(RabbitAdmin rabbitAdmin){
            return event -> rabbitAdmin.initialize();
        }
        para poder inicialize e mostra o admin

------------------------------------------------------------------------------------------------------------------------
Como citei algumas vezes ao longo dos vídeos anteriores, uma mensagem nunca é enviada diretamente para uma fila, ela sempre é direcionada para uma exchange, que será responsável por encaminhar as mensagens para diversas filas que estiverem conectadas a ela. Quando fazemos o envio sem informar a exchange, o próprio RabbitMQ já utiliza uma exchange do tipo default por debaixo dos panos, como vimos na aula anterior.

Quando optamos por informar a exchange, ao criá-la em nossa aplicação, temos algumas opções, que vou relembrar aqui:

Direct: Esse tipo de exchange é usada, geralmente, quando desejamos enviar mensagens para um consumidor específico. Para isso, utilizamos uma routing key, que é uma chave enviada junto com a mensagem para que a exchange identifique qual a fila irá receber a mensagem.
Fanout: Quando enviamos uma mensagem para uma exchange desse tipo, ela vai ser enviada para todas as filas que estiverem ligadas a essa exchange. Ou seja, se existirem 30 filas ligadas a essa exchange, essas 30 filas receberão a mensagem. Para conectar uma fila a uma exchange é preciso criar um bind, que é uma relação (ou vínculo) entre uma fila e uma exchange. Nomeia-se como binding key essa chave de ligação entre a fila e a exchange.
Headers: É um tipo muito menos usado, mas basicamente ignora o routing key e passa no próprio cabeçalho da mensagem para qual binding key deve ser encaminhada a mensagem.
Topic: A palavra-chave desse tipo de exchange é flexibilidade. Você pode nomear as binding keys de uma forma a criar padrões e/ou regras para que o envio seja de forma personalizada. Essas binding keys são descritas como se fossem expressões regulares. Dessa forma, podemos fazer composições para que mais de um consumidor receba as mensagens. Vou exemplificar abaixo:
alt text: Recorte da tela do RabbitMQ Simulator, em fundo branco, simulando o envio de uma mensagem do produtor “pedido” para mais de um consumidor utilizando uma topic exchange. O primeiro consumidor (“estoque”) recebe a mensagem de uma topic exchange, que envia a mensagem por meio de uma binding key “pedido.*” para a fila nomeada como “fila-estoque”. O segundo consumidor (“pagamento”) recebe a mensagem da mesma topic exchange, por meio de uma binding key “*.pagamento” que a direciona para a fila nomeada como “fila-pagamento”. Por fim, o terceiro consumidor (“financeiro”) recebe a mensagem pela topic exchange, por meio de uma binding key “pedido.*”, que a direciona para a fila denominada “fila-financeiro”.

Suponha que eu tenha uma aplicação produtora, chamada pedido. E em um determinado momento seja necessário mandar mensagem para apenas dois consumidores: o estoque, para confirmar se tem os itens do pedido, e para o financeiro, para ver se o cliente desse pedido tem alguma pendência.

Num segundo momento, eu vou querer enviar uma mensagem para esses dois consumidores e mais um terceiro, que é o pagamento. Para isso, configurei as minhas binding keys da seguinte forma:

As binding keys da fila-estoque e da fila-financeiro com a exchange, configurei como pedido.*

Já a binding key da fila-pagamento com a exchange, configurei como *.pagamento

Caso o pedido envie uma mensagem com a routing key pedido.criado, por exemplo, tanto o estoque quanto o financeiro receberão a mensagem, pois a routing key se enquadra no padrão que foi definido na binding key.

Caso o pedido envie uma mensagem com a routing key pedido.pagamento, os três consumidores receberão a mensagem, pois o roteamento atende aos dois padrões.

Dessa forma, é possível compor e estabelecer padrões para definir envios com rotas diferenciadas, baseado em alguma situação específica que somente uns ou outros consumidores precisem receber as mensagens.

Para melhor aproveitamento e performance no uso do RabbitMQ, é importante entender e modelar corretamente os tipos de exchanges para que se possa garantir uma comunicação eficiente entre os produtores e consumidores.



------------------------------------Lidando com falhas----------------------------------------------------------------------------------------------------------
spring.rabbitmq.listener.simple.retry.enabled=true
spring.rabbitmq.listener.simple.retry.max-attempts=4


aqui faz que ele tenta processar a mensagem novamente, pelo numero de tentativa de 4 vezes
se der errado para de tentar e segue para outra

spring.rabbitmq.listener.simple.retry.initial-interval=5000
spring.rabbitmq.listener.simple.retry.multiplier=1
spring.rabbitmq.listener.simple.retry.max-interval=300000
aqui para fazer maximo de tempo para cada tentativa
--------------------------------------DLQs e DLXs---------------------------------------------------------------------------------
redireciona o erro para um lugar que tem mensagem morta
isso tudo pode ser resolvido na class que tem listener

primeiro tem criar fanout que represente onde essa mensagem vai ser mandanda ou enviada
caso de algum erro
    @Bean
    public FanoutExchange deadLetterExchange() {
        return ExchangeBuilder
                .fanoutExchange("login.dlx")
                .build();
    }

e depois criar a fila para onde ela vai ser jogada para ficar esperando
 @Bean
    public Queue filaDlqDetalhesAvaliacao() {
        return QueueBuilder
                .nonDurable("pagamentos.detalhes-avaliacao-dlq")
                .build();
    }
depois para fazer união deste dois
  @Bean
    public Binding bindDlxPagamentoPedido() {
        return BindingBuilder
                .bind(filaDlqDetalhesAvaliacao())
                .to(deadLetterExchange());
    }

agora para indicar para onde mensagem morta ou mensagem que teve erro deve ser mandada
so na propria hora de criar a fila indicar o deadLetterExchange e indicar o fanoutExchange que vai ser mandando
  @Bean
    public Queue creatingQueue(){
        //return new Queue("registered.completed",false);
        return QueueBuilder
                .nonDurable("registered.completed")
                .deadLetterExchange("login.dlx")
                .build();
    }















    Depois, vamos configurar em application.properties o número máximo de tentativas, para que as mensagens com erro não atrapalhem o fluxo das mensagens posteriores. Posso configurar também intervalos para essas novas tentativas, para que não ocorram imediatamente após a tentativa anterior.

    spring.rabbitmq.listener.simple.retry.enabled=true
    spring.rabbitmq.listener.simple.retry.max-attempts=5
    spring.rabbitmq.listener.simple.retry.initial-interval=5000
    spring.rabbitmq.listener.simple.retry.multiplier=2
    spring.rabbitmq.listener.simple.retry.max-interval=300000COPIAR CÓDIGO
    Para que as mensagens com erro sejam direcionadas a outra fila, na classe AvaliacaoAMQPConfiguration precisamos criar a dead letter queue, a dead letter exchange e vinculá-las através do Binding:

    @Bean
        public Queue filaDlqDetalhesAvaliacao() {
            return QueueBuilder
                    .nonDurable("pagamentos.detalhes-avaliacao-dlq")
                    .build();
        }

    @Bean
        public FanoutExchange deadLetterExchange() {
            return ExchangeBuilder
                    .fanoutExchange("pagamentos.dlx")
                    .build();
        }

     @Bean
        public Binding bindDlxPagamentoAvaliacao() {
            return BindingBuilder
                    .bind(filaDlqDetalhesAvaliacao())
                    .to(deadLetterExchange());
        }COPIAR CÓDIGO
    Por fim, precisamos indicar, em nossa fila principal, o nome da dead letter exchange para qual ela deve encaminhar as mensagens não processadas:

     @Bean
        public Queue filaDetalhesAvaliacao() {
            return QueueBuilder
                    .nonDurable("pagamentos.detalhes-avaliacao")
                    .deadLetterExchange("pagamentos.dlx")
                    .build();
        }

---------------------------------------------Movendo mensagens da DLQ----------------------------------------------------------
uma das alternativa é "Move messages"., no dlq
vc coloca no dlq na fila deleque, "Move messages". e para que fila tem que ser enviada
